{
    "collab_server" : "",
    "contents" : "library(dplyr)\nlibrary(data.table)\nlibrary(reshape)\n\nAmazon_Video_2000 <- as.data.table(ratings_Cell_Phones_and_Accessories)\nAmazon_Video_2000 <- Amazon_Video_2000[Date %like% \"2003\"]\n\n##Get Desired Columns\nAmazon_Video_2000_matrix <- Amazon_Video_2000[,1:3]\nAmazon_Video_2000_matrix\n\n##Pivot the Table\nAmazon_Video_2000_matrix_1 <- cast(Amazon_Video_2000_matrix, userId ~ itemId)\n\n#Replace NA's with 0's\nAmazon_Video_2000_matrix_1[is.na(Amazon_Video_2000_matrix_1)] <- 0\n\n# Drop any column named \"user\"\nvideo_matrix <- (Amazon_Video_2000_matrix_1[,!(names(Amazon_Video_2000_matrix_1) %in% c(\"userId\"))])\n\n# Create a helper function to calculate the cosine between two vectors\ngetCosine <- function(x,y) \n{\n  this.cosine <- sum(x*y) / (sqrt(sum(x*x)) * sqrt(sum(y*y)))\n  return(this.cosine)\n}\n\n\n# Create a placeholder dataframe listing item vs. item\nholder  <- matrix(NA,nrow=ncol(video_matrix),ncol=ncol(video_matrix),dimnames=list(colnames(video_matrix),colnames(video_matrix)))\n\nvideo_matrix_similarity <- as.data.frame(holder)\n\n# Lets fill in those empty spaces with cosine similarities\nfor(i in 1:ncol(video_matrix)) {\n  for(j in 1:ncol(video_matrix)) {\n    video_matrix_similarity[i,j]= getCosine(video_matrix[i],video_matrix[j])\n  }\n}\n\nhead.matrix(video_matrix_similarity)\n\n# Get the top 5 neighbours for each : Place Holder\nVideo_matrix_neighbours <- matrix(NA,nrow=ncol(video_matrix_similarity),ncol=5,dimnames=list(colnames(video_matrix_similarity)))\n\n\nhead.matrix(Video_matrix_neighbours)\n\n##Lets fill the Neighbours Matrix\nfor(i in 1:ncol(video_matrix)) \n{\n  Video_matrix_neighbours[i,] <- (t(head(n=5,rownames(video_matrix_similarity[order(video_matrix_similarity[,i],decreasing=TRUE),][i]))))\n}\n\nhead.matrix(Video_matrix_neighbours)\n\nwrite.csv(Video_matrix_neighbours, file = \"cellphones_2013ItemRecommendation.csv\")\n\n\n####################################################################################################################\nVideo_matrix_neighbours_1 <- data.frame(Video_matrix_neighbours)\nVideo_matrix_neighbours_1$itemid <- rownames(Video_matrix_neighbours_1)\n\nVideo_matrix_neighbours_1$item <- left_join(Video_matrix_neighbours_1, query_result_18, by=\"itemid\", all.y = TRUE)\nVideo_matrix_neighbours_1$itemt1 <- left_join(Video_matrix_neighbours_1, query_result_18, by=\"itemid1\", all.y = TRUE)\n#####################################################################################################################\n\n############################################################################\n#####################ITEM RECOMMENDATIONS#####################################\n## Item         #[,1]         [,2]         [,3]         [,4]         [,5]        \n#B000ID1PUI \"B000ID1PUI\" \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\" \"B000W453KQ\"\n#B000JIJMBQ \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\" \"B000ID1PUI\" \"B000W453KQ\"\n#B000MN4YR0 \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\" \"B000ID1PUI\" \"B000W453KQ\"\n#B000MN6XQK \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\" \"B000ID1PUI\" \"B000W453KQ\"\n#B000W453KQ \"B000W453KQ\" \"B000ID1PUI\" \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\"\n#B0032DGB5K \"B0032DGB5K\" \"B000ID1PUI\" \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\"\n\n##############################################################################\n\n##USer Score Matrix\n# Lets make a helper function to calculate the scores\ngetScore <- function(history, similarities)\n{\n  x <- sum(history*similarities)/sum(similarities)\n  x\n}\n\n\nholder_1 <- matrix(NA, nrow=nrow(Amazon_Video_2000_matrix_1),ncol=ncol(Amazon_Video_2000_matrix_1)-1,dimnames=list((Amazon_Video_2000_matrix_1$userId),colnames(Amazon_Video_2000_matrix_1[-1])))\n\n\n# Loop through the users (rows)\nfor(i in 1:nrow(holder_1)) \n{\n  # Loops through the products (columns)\n  for(j in 1:ncol(holder_1)) \n  {\n    # Get the user's name and th product's name\n    # We do this not to conform with vectors sorted differently \n    user <- rownames(holder_1)[i]\n    product <- colnames(holder_1)[j]\n    \n    # We do not want to recommend products you have already consumed\n    # If you have already consumed it, we store an empty string\n    if(as.integer(Amazon_Video_2000_matrix_1[Amazon_Video_2000_matrix_1$userId==user,product]) == 1)\n    { \n      holder_1[i,j]<-\"\"\n    } else {\n      \n      # We first have to get a product's top 10 neighbours sorted by similarity\n      topN<-((head(n=5,(video_matrix_similarity[order(video_matrix_similarity[,product],decreasing=TRUE),][product]))))\n      topN.names <- as.character(rownames(topN))\n      topN.similarities <- as.numeric(topN[,1])\n      \n      # Drop the first one because it will always be the same song\n      topN.similarities<-topN.similarities[-1]\n      topN.names<-topN.names[-1]\n      \n      # We then get the user's purchase history for those 10 items\n      topN.purchases<- Amazon_Video_2000_matrix_1[,c(\"userId\",topN.names)]\n      topN.userPurchases<-topN.purchases[topN.purchases$userId==user,]\n      topN.userPurchases <- as.numeric(topN.userPurchases[!(names(topN.userPurchases) %in% c(\"userId\"))])\n      \n      # We then calculate the score for that product and that user\n      holder_1[i,j]<-getScore(similarities=topN.similarities,history=topN.userPurchases)\n      \n    } # close else statement\n  } # end product for loop   \n} # end user for loop\n\n\nAmazon_Video_2000_matrix_scores <- holder_1\n\n# Lets make our recommendations pretty\nAmazon_Video_2000_matrix_scores_holder <- matrix(NA, nrow=nrow(Amazon_Video_2000_matrix_scores),ncol=5,dimnames=list(rownames(Amazon_Video_2000_matrix_scores)))\n\nfor(i in 1:nrow(Amazon_Video_2000_matrix_scores)) \n{\n  Amazon_Video_2000_matrix_scores_holder[i,] <- names(head(n=5,(Amazon_Video_2000_matrix_scores[,order(Amazon_Video_2000_matrix_scores[i,],decreasing=TRUE)])[i,]))\n}\n\nhead.matrix(Amazon_Video_2000_matrix_scores_holder)\n\n##################################################################################\n#####################USER RECOMMENDATIONS#########################################\n###                 [,1]         [,2]         [,3]         [,4]         [,5]        \n###A136YD08SCJ2LV \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\" \"B000ID1PUI\" \"B000W453KQ\"\n###A1GDRNK3Y5IG9Z \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\" \"B000ID1PUI\" \"B000W453KQ\"\n###A1X4JO8EJ1U5BR \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\" \"B000ID1PUI\" \"B000W453KQ\"\n###A20EEWWSFMZ1PN \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\" \"B000ID1PUI\" \"B000W453KQ\"\n###A282IMYVM6GP1L \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\" \"B000ID1PUI\" \"B000W453KQ\"\n###A2W9J1ZCL5N1ZB \"B000JIJMBQ\" \"B000MN4YR0\" \"B000MN6XQK\" \"B000ID1PUI\" \"B000W453KQ\"\n\n\n#################################################################################\n#################################################################################\n\ntryy <- \"A136YD08SCJ2LV\"\nfor( tryy in rownames(Amazon_Video_2000_matrix_scores_holder) )\n{\n  \n  try <- Amazon_Video_2000_matrix_scores_holder[i,]\n  \n}\n\nas.data.frame(try)\n",
    "created" : 1481505637443.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1907990792",
    "id" : "7EC74BAF",
    "lastKnownWriteTime" : 1481525078,
    "last_content_update" : 1481525078032,
    "path" : "H:/Big Data Project/Amazon_New/Cellphones_Recommendations.R",
    "project_path" : "Cellphones_Recommendations.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}